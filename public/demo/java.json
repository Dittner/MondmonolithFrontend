{"uid":"java","title":"Java","directory":"Backend","pages":[{"uid":"188a4a1c0b9-8a117169-4","title":"Java Collection","blocks":[{"uid":"188a4a1c0b9-8a117169-6","text":"The Java collections framework provides a set of interfaces and classes to implement various data structures and algorithms."},{"uid":"188a4a1c0b9-8a117169-7","text":"## interface Collection"},{"uid":"188a4a1c0b9-8a117169-5","text":"```java\ninterface Collection<E> (\n  boolean add(E element);\n  Iterator<E> iterator();\n  int size();\n  boolean isEmpty();  \n  ...\n}\n\npublic interface Iterable<E> (\n  Iterator<E> iterator();\n}\n\npublic interface Iterator<E> {\n  Е next();\n  boolean hasNext();\n  //removes the element received by the last invoking of the func next()\n  void remove();\n}\n\nCollection<String> c = ...;\nIterator<String> iter = c.iterator();\nwhile (iter.hasNext()) {\n  String element = iter.next();\n  ...\n}\n\nfor (String element : с) {\n  ...\n}\n```"},{"uid":"188a4a1c0b9-8a117169-8","text":"## List\n`interface List<E> extends Collection<E>`"},{"uid":"188a4a1c0b9-8a117169-27","text":"The _List_ declares the behavior of a collection that stores a sequence of elements. Elements can be inserted or accessed by their position in the list, using a zero-based index. A list may contain duplicate elements."},{"uid":"188a4a1c0b9-8a117169-9","text":"```java\nList<String> list = List.of(\"one\", \"two\", \"three\");\n```"},{"uid":"188a4a1c0b9-8a117169-a","text":"## ArrayList\n`class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-28","text":"The __ArrayList__ class extends __AbstractList__ and implements the _List_ interface. __ArrayList__ supports dynamic arrays that can grow as needed."},{"uid":"188a4a1c0b9-8a117169-b","text":"```java\nvar languages = new ArrayList<String>();\nlanguages.add(\"Java\");\nlanguages.add(\"C++\");\nlanguages.add(\"Python\");\n\nString str = languages.get(1); //C++\nlanguages.set(1, \"JavaScript\");\nString str = languages.get(1); //JavaScript\nString str = languages.remove(2); //Python\nlanguages.size() //2\n```"},{"uid":"188a4a1c0b9-8a117169-c","text":"## LinkedList\n`class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-29","text":"__LinkedList__ is a linear data structure where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers."},{"uid":"188a4a1c0b9-8a117169-e","text":"Due to the dynamicity and ease of insertions and deletions, they are preferred over the arrays. But the nodes cannot be accessed directly instead we need to start from the head and follow through the link to reach a node we wish to access. Therefore the complexity of the binary search in the __LinkedList__ is O(n)."},{"uid":"188a4a1c0b9-8a117169-d","text":"```java\nLinkedList ll = new LinkedList();\nll.add(\"1\");\nll.add(\"2\");\nll.add(\"3\");\nll.addLast(\"9\");\nll.addFirst(\"0\");\nll.add(4, \"4\");\n```"},{"uid":"188a4a1c0b9-8a117169-f","text":"## Set\n`interface Set<E> extends Collection<E>`"},{"uid":"188a4a1c0b9-8a117169-2a","text":"This is an unordered collection of objects in which duplicate values cannot be stored."},{"uid":"188a4a1c0b9-8a117169-10","text":"```java\nSet<String> set = Set.of(\"one\", \"two\", \"three\");\n```"},{"uid":"188a4a1c0b9-8a117169-11","text":"## HashSet\n`class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-2b","text":"- HashSet is backed by a hash table which is actually a __HashMap__ instance;\n- The class also offers constant time performance for the basic operations like add, remove, contains;\n- HashSet also implements _Serializable_ and _Cloneable_ interfaces;\n- When adding an object, it's hashCode is used."},{"uid":"188a4a1c0b9-8a117169-12","text":"```java\nHashSet<String> h = new HashSet<String>();\nh.add(\"India\");\nh.add(\"Australia\");\nh.add(\"South Africa\");\n```"},{"uid":"188a4a1c0b9-8a117169-13","text":"## LinkedHashSet\n`class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-2c","text":"The __LinkedHashSet__ is an ordered version of __HashSet__ that maintains a doubly-linked List across all elements. __LinkedHashSet__ is backed by __LinkedHashMap__."},{"uid":"188a4a1c0b9-8a117169-14","text":"## TreeSet\n`class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-2d","text":"The ordering of the elements is maintained by a set using their natural ordering whether or not an explicit comparator is provided. __TreeSet__ is an implementation of a self-balancing tree. __TreeSet__ serves as an excellent choice for storing large amounts of sorted information which are supposed to be accessed quickly because of its faster access and retrieval time."},{"uid":"188a4a1c0b9-8a117169-15","text":"```java\nvar parts = new TreeSet<Item>();\nparts.add(new Item(\"Toaster\", 1234));\nparts.add(new Item(\"Widget\", 4562));\nparts.add(new Item(\"Modem\", 9912));\n\nvar sortByDescription = new TreeSet<Item>(Comparator.comparing(Item::getDescription));\nsortByDescription.addAll(parts);\n```"},{"uid":"188a4a1c0b9-8a117169-16","text":"## Queue\n`interface Queue<E> extends Collection<E>`"},{"uid":"188a4a1c0b9-8a117169-2e","text":"It is an ordered list of objects with its use limited to inserting elements at the end of the list and deleting elements from the start of the list, it follows the First-In-First-Out principle."},{"uid":"188a4a1c0b9-8a117169-17","text":"```java\ninterface Queue<E> {\n  void add(E element); \n  Е remove();\n  int size();\n}\n```"},{"uid":"188a4a1c0b9-8a117169-18","text":"## PriorityQueue\n`class PriorityQueue<E> extends AbstractQueue<E> implements Serializable`"},{"uid":"188a4a1c0b9-8a117169-2f","text":"An unbounded priority queue based on a priority heap. The elements of the priority queue are ordered according to their natural ordering, or by a _Comparator_ provided at queue construction time, depending on which constructor is used. A priority queue does not permit null elements."},{"uid":"188a4a1c0b9-8a117169-19","text":"## ArrayDeque\n`class ArrayDeque<E> extends AbstractCollection<E> implements Deque<E>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-30","text":"Resizable-array implementation of the _Deque_ interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than __LinkedList__ when used as a queue."}]},{"uid":"188a4a1c0b9-8a117169-1b","title":"Java Map","blocks":[{"uid":"188a4a1c0b9-8a117169-1c","text":"## interface Map\nMaps are perfect to use for key-value association mapping such as dictionaries. The maps are used to perform lookups by keys or when someone wants to retrieve and update elements by keys.\n\n+ A _Map_ cannot contain duplicate keys and each key can map to at most one value. Some implementations allow null key and null values like the __HashMap__ and __LinkedHashMap__, but some do not like the __TreeMap__.\n+ The order of a map depends on the specific implementations. For example, __TreeMap__ and __LinkedHashMap__ have predictable orders, while __HashMap__ does not.\n+ There are two interfaces for implementing _Map_ in Java. They are _Map_ and _SortedMap_, and three classes: __HashMap__, __TreeMap__, and __LinkedHashMap__."},{"uid":"188a4a1c0b9-8a117169-1d","text":"```java\ninterface Map<K,V> (\n  boolean containsKey(K key)\n  V get(K key)\n  V put(K key, V value)\n  V remove(K key)\n  int size()\n  void clear()\n  boolean isEmpty();\n  Collection<V> values()\n  ...\n}\n```"},{"uid":"188a4a1c0b9-8a117169-1e","text":"## HashMap\n`class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-1f","text":"```java\nMap<Integer,String> map=new HashMap<Integer,String>();  \nmap.put(0, \"Zero\");    \nmap.put(1, \"One\");    \nmap.put(2, \"Two\");  \n//Elements can traverse in any order  \nfor(Map.Entry m:map.entrySet()){  \n    System.out.println(m.getKey() + \" \" + m.getValue());  \n}  \n```"},{"uid":"188a4a1c0b9-8a117169-20","text":"## LinkedHashMap\n`class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>  `"},{"uid":"188a4a1c0b9-8a117169-21","text":"```java\nLinkedHashMap<Integer, String> map = new LinkedHashMap<Integer, String>();           \nmap.put(0, \"Zero\");    \nmap.put(1, \"One\");    \nmap.put(2, \"Two\");    \n    \nSystem.out.println(map.keySet()); //[0, 1, 2]  \nSystem.out.println(map.values()); //[Zero, One, Two]\nSystem.out.println(map.entrySet()); //[0=Zero, 1=One, 2=Two]\n```"},{"uid":"188a4a1c0b9-8a117169-23","text":"## TreeMap\n`class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable`"},{"uid":"188a4a1c0b9-8a117169-22","text":"TreeMap class is a red-black tree based implementation. It provides an efficient means of storing key-value pairs in sorted order."},{"uid":"188a4a1c0b9-8a117169-24","text":"## WeakHashMap\n`class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>`"},{"uid":"188a4a1c0b9-8a117169-25","text":"The __WeakHashMap__ is a hashtable-based implementation of the _Map_ interface, with keys that are of a __WeakReference__ type."},{"uid":"188a4a1c0b9-8a117169-26","text":"```java\nInteger value = 1;  \nWeakReference<Integer> soft = new WeakReference<Integer>(value); \nvalue = null; //value will be garbage collected in the next GC cycle\n\nWeakHashMap<UniqueImageName, BigImage> map = new WeakHashMap<>();\nBigImage bigImage = new BigImage(\"image_id\");\nUniqueImageName imageName = new UniqueImageName(\"name_of_big_image\");\n\n//The imageName will be stored in a map as a WeakReference type.\nmap.put(imageName, bigImage);\nimageName = null;\n\n//We are calling a System.gc() to force the JVM to trigger a GC process.\n//After the GC cycle, our WeakHashMap will be empty.\nSystem.gc();\n```"}]},{"uid":"18877eb8dd8-8cf02f24-1e","title":"Pattern Memento","blocks":[{"uid":"188a47b9757-597c4370-4","text":"```java\ninterface HistoryAction {\n    void undo();\n    void redo();\n    void dispose();\n}\n```"},{"uid":"188a21bf7f2-47b8252b-4","text":"```java\nimport java.util.function.Consumer;\n\nclass HistoryActionImpl<T> implements HistoryAction {\n  private T valueBefore;\n  private T valueAfter;\n  private Consumer<? super T> consumer;\n  private boolean undone = false;\n  \n  HistoryActionImpl(Consumer<? super T> consumer, T valueBefore, T valueAfter) {\n    this.consumer = consumer;\n    this.valueBefore = valueBefore;\n    this.valueAfter = valueAfter;\n  }\n  \n  @Override\n  public void undo() {\n    if (!undone) {\n      undone = true;\n      this.consumer.accept(valueBefore);\n    }\n  }\n  \n  @Override\n  public void redo() {\n    if (undone) {\n      undone = false;\n      this.consumer.accept(valueAfter);\n    }\n  }\n  \n  @Override\n  public void dispose() {\n    this.valueBefore = null;\n    this.valueAfter = null;\n    this.consumer = null;\n  }\n}\n```"},{"uid":"188a21bf7f2-47b8252b-5","text":"```java\nimport java.util.LinkedList;\nimport java.util.List;\n\nclass ActionHistory {\n  ActionHistory(int capacity) {\n    this.capacity = capacity;\n  }\n  \n  private List<HistoryAction> actionQueue = new LinkedList<>();\n  private final int capacity;\n  \n  public int getCapacity() {\n    return capacity;\n  }\n  \n  public int getSize() {\n    return actionQueue.size();\n  }\n  \n  private int rollbackDepth = 0;\n  \n  private HistoryAction getCurAction() {\n    if (rollbackDepth + 1 > 0) {\n      return actionQueue.get(actionQueue.size() - rollbackDepth - 1);\n      } else {\n      return null;\n    }\n  }\n  \n  public Boolean canRedo() {\n    return rollbackDepth > 0;\n  }\n  \n  public Boolean canUndo() {\n    return rollbackDepth < actionQueue.size();\n  }\n  \n  public void undo() {\n    if (canUndo()) {\n      getCurAction().undo();\n      rollbackDepth++;\n    }\n  }\n  \n  public void redo() {\n    if (canRedo()) {\n      rollbackDepth--;\n      getCurAction().redo();\n    }\n  }\n  \n  public void add(HistoryAction action) {\n    for (int i = actionQueue.size() - rollbackDepth; i < actionQueue.size(); i++) {\n      actionQueue.get(i).dispose();\n    }\n    \n    actionQueue = actionQueue.subList(0, actionQueue.size() - rollbackDepth);\n    actionQueue.add(action);\n    rollbackDepth = 0;\n    normalizeQueue();\n  }\n  \n  public void clear() {\n    actionQueue.forEach(HistoryAction::dispose);\n    actionQueue.clear();\n    rollbackDepth = 0;\n    normalizeQueue();\n  }\n  \n  private void normalizeQueue() {\n    while (actionQueue.size() > capacity) {\n      actionQueue.remove(0).dispose();\n    }\n    if (rollbackDepth > actionQueue.size()) rollbackDepth = actionQueue.size();\n  }\n}\n```"}]}]}